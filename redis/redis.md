# Redis
## 主从库数据如何实现一致
- 高性能的必然要求，服务尽量不要中断，因此要有主从库
- 第一次同步，从库调用`replicaof 主库IP 6379`
1. 从库给主库发送psync命令包含参数`runID=?, offset=-1`
2. 主库准备好，发送FULLRESYNC，包含参数自己的runID和offset
- 主库传送RDB文件，从库读RDB到内存
1. 主库执行bgsave命令，生产最新的RDB文件，把RDB文件传送从库
2. 从库把本地数据清空，把RDB文件读进内存
3. 在同步过程中，主库没有被阻塞，主库会把同步过程中产生的新的写命令存入`replication buffer`
- 主库把`replication buffer`中的命令传给从库
- 主从级联模式
1. 分担主库全量复制的压力
2. 主库fork子进程生成RDB文件会阻塞
3. 主库传送RDB文件时会占用带宽
4. 通过`主-从-从`的模式将主库生产RDB已经传输的压力放在从库上
- 基于长连接的命令传播
- 主从库网络断连
1. 断连时主库会把收到的写操作命令写入到`repl_backlog_buffer`这个缓冲区
2. `repl_backlog_buffer`是一个环形缓冲区，主库会记录自己写到的位置，从库会记录自己读到的位置
3. 连接重新连上后，从库发送的psync中包含`slave_repl_offset`,主库收到后对比自己的`master_repl_offset`,发送两者之间的命令
4. 增量复制(重连以后)
5. `repl_backlog_size`设置的大一点，令其等于`主库写入命令速度*操作大小-主从库间网络传输速度*操作大小`*2
6. 一个从库如果和主库断连时间过长，造成它在主库`repl_backlog_buffer`的`slave_repl_offset`位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。

- 主从全量同步使用RDB而不使用AOF的原因
1. RDB是压缩过的文件，AOF是命令，可能有冗余
2. 从库加载RDB文件时很快，读AOF时需要一条一条执行，慢！
## 哨兵机制：主库挂了，如何不间断服务
- 哨兵
1. 哨兵是一个运行在特殊模式下的redis进程
   1. 监控-周期性的给主从库发送ping命令
   2. 选主
   3. 通知-给其它从库发通知，给客户端发通知
2. 引入哨兵集群来解决误判问题
   1. 有N个哨兵，至少有N/2+1个主观下线后才认定客观下线
3. 如何选主
   1. 筛选-不符合条件的从库去掉
      1. 除了当前的在线状态
      2. 还要判断以前的状态
      3. `down-after-miliseconds*10`,有十次断连
   2. 打分-按照一定的规则，得分高的选为主库
      1. 从库优先级-配置`slave-priority`
      2. 从库复制进度-`slave-repl-offset`最接近`master-repl-offset`
      3. 从库ID号-小的得分高

## 哨兵挂了，还能主从切换吗
- 配置哨兵 `sentinel monitor <master-name> <ip> <redis-port> <quorum>`
- 哨兵之间相互发现，通过Redis提供的`sub/pub`机制
1. 哨兵和主库建立连接，在主库发布消息(比如自己ip和端口)
2. 哨兵也可以订阅别的哨兵的信息，这样就可以和别的哨兵建立连接
3. 哨兵统一订阅`__sentinel__:hello`频道
- 哨兵还需要和从库建立连接
1. 哨兵向主库发送INFO命令
2. 主库把从库列表信息发送过去
3. 哨兵和从库建立连接

- 哨兵需要通知客户端
1. 哨兵本身就是一个redis，可以被订阅
2. 哨兵把主库选出来后，客户端会收到事件`swith-master <master name> <oldip> <oldport> <newip> <newport>`
   
- 由哪个哨兵执行主从切换
1. 投票选举，类似Raft协议
2. 成为leader的两个条件
   1. 拿到半数以上的赞成票
   2. 赞成票大于等于quorum

## 切片集群
- 数据太多时响应会特别慢，主要是RDB时fork操作时间太长阻塞了主线程
  - 可以用INFO命令查询`latest_fork_usec`

- 数据分片与实例的对应分布情况
1. Redis Cluster通过哈希槽
2. 16384，2的128次方个槽，固定的
3. 把键值做CRC16算法得到16bit的值，然后对16384取模
4. 如何把槽分配到实例上
   1. 可以直接用`cluster create`创建，会自动均分到N个实例上，每个实例16384/N个槽
   2. 手动。`cluster meet`创建集群，`cluster addslots`指定每个实例上具体槽

- 客户端如何定位数据
1. Redis实例会通过gossip协议和自己相连的实例同步哈希槽信息
2. 客户端会把所有哈希槽信息缓存在本地
3. 实例和哈希槽对应关系可能变化，比如实例增减、负载均衡等
   1. 在变化期间，客户端不知道
   2. gossip协议需要时间来更新
   3. 通过重定向机制解决`MOVED 哈希槽值 新实例：端口`客户端会重新向新实例发起请求并更新本地缓存
   4. 哈希槽数据迁移一半
      1. `ASK 哈希槽值 新实例：端口`
      2. ASK表示哈希槽正在迁移，让客户端先给新实例发送一个ASKing命令，让它接收客户端的查询
      3. 注意ASK命令不更新客户端本地缓存