# Redis
## 主从库数据如何实现一致
- 高性能的必然要求，服务尽量不要中断，因此要有主从库
- 第一次同步，从库调用`replicaof 主库IP 6379`
1. 从库给主库发送psync命令包含参数`runID=?, offset=-1`
2. 主库准备好，发送FULLRESYNC，包含参数自己的runID和offset
- 主库传送RDB文件，从库读RDB到内存
1. 主库执行bgsave命令，生产最新的RDB文件，把RDB文件传送从库
2. 从库把本地数据清空，把RDB文件读进内存
3. 在同步过程中，主库没有被阻塞，主库会把同步过程中产生的新的写命令存入`replication buffer`
- 主库把`replication buffer`中的命令传给从库
- 主从级联模式
1. 分担主库全量复制的压力
2. 主库fork子进程生成RDB文件会阻塞
3. 主库传送RDB文件时会占用带宽
4. 通过`主-从-从`的模式将主库生产RDB已经传输的压力放在从库上
- 基于长连接的命令传播
- 主从库网络断连
1. 断连时主库会把收到的写操作命令写入到`repl_backlog_buffer`这个缓冲区
2. `repl_backlog_buffer`是一个环形缓冲区，主库会记录自己写到的位置，从库会记录自己读到的位置
3. 连接重新连上后，从库发送的psync中包含`slave_repl_offset`,主库收到后对比自己的`master_repl_offset`,发送两者之间的命令
4. 增量复制(重连以后)
5. `repl_backlog_size`设置的大一点，令其等于`主库写入命令速度*操作大小-主从库间网络传输速度*操作大小`*2
6. 一个从库如果和主库断连时间过长，造成它在主库`repl_backlog_buffer`的`slave_repl_offset`位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。

- 主从全量同步使用RDB而不使用AOF的原因
1. RDB是压缩过的文件，AOF是命令，可能有冗余
2. 从库加载RDB文件时很快，读AOF时需要一条一条执行，慢！
## 哨兵机制：主库挂了，如何不间断服务
- 哨兵
1. 哨兵是一个运行在特殊模式下的redis进程
   1. 监控-周期性的给主从库发送ping命令
   2. 选主
   3. 通知-给其它从库发通知，给客户端发通知
2. 引入哨兵集群来解决误判问题
   1. 有N个哨兵，至少有N/2+1个主观下线后才认定客观下线
3. 如何选主
   1. 筛选-不符合条件的从库去掉
      1. 除了当前的在线状态
      2. 还要判断以前的状态
      3. `down-after-miliseconds*10`,有十次断连
   2. 打分-按照一定的规则，得分高的选为主库
      1. 从库优先级-配置`slave-priority`
      2. 从库复制进度-`slave-repl-offset`最接近`master-repl-offset`
      3. 从库ID号-小的得分高

## 哨兵挂了，还能主从切换吗
- 配置哨兵 `sentinel monitor <master-name> <ip> <redis-port> <quorum>`
- 哨兵之间相互发现，通过Redis提供的`sub/pub`机制
1. 哨兵和主库建立连接，在主库发布消息(比如自己ip和端口)
2. 哨兵也可以订阅别的哨兵的信息，这样就可以和别的哨兵建立连接
3. 哨兵统一订阅`__sentinel__:hello`频道
- 哨兵还需要和从库建立连接
1. 哨兵向主库发送INFO命令
2. 主库把从库列表信息发送过去
3. 哨兵和从库建立连接

- 哨兵需要通知客户端
1. 哨兵本身就是一个redis，可以被订阅
2. 哨兵把主库选出来后，客户端会收到事件`swith-master <master name> <oldip> <oldport> <newip> <newport>`
   
- 由哪个哨兵执行主从切换